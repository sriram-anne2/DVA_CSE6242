y_recursive = NULL
times = NULL
y = NULL
i=0
j=0
k=0
times1_loop = NULL
y1_loop = NULL
times1_recursive = NULL
y1_recursive = NULL
times1 = NULL
y1 = NULL
for(i in 1:3000) {
times_loop = system.time(sum_log_gamma_loop(i))['elapsed']
y_loop <- append(y_loop,times_loop)
}
for (j in 1:3000) {
times = system.time(sum_lgamma(j))['elapsed']
y <- append(y,times)
}
for (k in 1:3000) {
times_recursive = system.time(sum_log_gamma_recursive(k))['elapsed']
y_recursive <- append(y_recursive, times_recursive)
}
plot(y_loop)
plot(y)
plot(y_recursive)
plot(y_loop)
plot(y_recursive)
plot(y_loop)
plot(y)
plot(y_recursive)
y
max.print(y)
plot(y_loop, type = "o", col = "red")
plot(y_loop, type = "o", pch = 22, lty = 2, col = "red")
plot(y_loop, type = "o", pch = 22, lty = 4, col = "red")
plot(y_loop, type = "o", pch = 15, lty = 4, col = "red")
plot(y_loop, type = "o", pch = 22, lty = 2, col = "red")
plot(y_loop, type = "o", pch = 2, lty = 2, col = "red")
plot(y_loop, type = "o", pch = 1, lty = 2, col = "red")
plot(y_loop, type = "o", pch = 5, lty = 5, col = "red")
plot(y, col = "blue")
plot(y, type = "o", col = "blue")
plot(y_recursive, type = "o", col = "forestgreen")
plot(y_loop, type = "o", col = "red")
plot(y_loop, type = "o", col = "red", xlab = "value of n", ylab = "execution time")
plot(y_loop, type = "o", col = "red", xlab = "value of n", ylab = "execution time", title = "TEST")
plot(y_loop, type = "o", col = "red", xlab = "value of n", ylab = "execution time", main = "test" )
plot(y_loop, type = "o", col = "red", xlab = "Value of n", ylab = "System Execution Time", main = "SUM_LOG_GAMMA_LOOP" )
plot(y, type = "o", col = "blue", xlab = "Value of n", ylab = "System Execution Time", main = "SUM_LOG_GAMMA_BUILT IN")
plot(y_recursive, type = "o", col = "forestgreen", xlab = "Value of n", ylab = "System Execution Time", main = "SUM_LOG_GAMMA_RECURSIVE")
plot(y, type = "o", col = "blue", xlab = "Value of n", ylab = "System Execution Time", main = "SUM_LGAMMA")
data(mtcars)
names(mtcars)
mtcars
View(mtcars)
?str(mtcars)
str(mtcars)
dim(mtcars)
row.names
?row.names
row.names(mtcars)
row.names(mtcars) <- c(1:32)
mtcars
View(mtcars)
data(mtcars)
head(mtcars, 10)
head(mtcars)
tail(mtcars, 3)
View(mtcars)
mtcars$mpg
mtcars$cyl
mtcars$cyl
mean(mtcars$mpg)
getwd
getwd()
a = 3.2
a = "a string"
print("The variable 'a' stores:"); print(a)
stopifnot(a == "a string");
stopifnot(TRUE || FALSE)
stopifnot(!(TRUE && FALSE))
?stopifnot
data("faithful")
names(faithful)
plot(faithful$eruptions, xlab = "sample number", ylab = "eruption times(min)", main = "Old Faithful Erution Times")
View(faithful)
qplot(x = waiting, data = faithful, binwidth = 3, main = "waiting time to next eruption (min)")
library(ggplot2)
qplot(x = waiting, data = faithful, binwidth = 3, main = "waiting time to next eruption (min)")
ggplot(faithful, aes(x = waiting)) + geom_histogram((binwidth = 1))
ggplot(faithful, aes(waiting)) + geom_histogram(binwidth = 1)
data("mtcars")
names(mtcars)
x = seq(-2,2,length.out = 30)
y = x^2
qplot(x,y,geom = "line")
qplot(x,y,geom = c("point","line"))
dataframe = data.frame(x,y)
ggplot(dataframe, aes(x,y)) + geom_line() + geom_point()
qplot(x,y,geom = "line")
ggplot(dataframe, aes(x,y)) + geom_line() + geom_point()
S = sort.int(mpg$cty, index.return = T)
View(S)
plot(S$x, type = "l", lty = 2, xlab = "sample number (sorted by city mpg)", ylab = "mpg")
lines(mpg$hwy[S$ix], lty = 1)
legend("topleft", c("highway mpg", "city mpg"), lty = c(1,2))
library(ggplot2)
data("midwest")
names(midwest)
View(midwest)
library(ggplot2)
data("faithful")
plot(faithful$waiting, faithful$eruptions,
pch = 17, col = 2, cex = 1.2,
xlab = "waiting times", ylab = "eruption times")
data("mtcars")
data(mpg)
install.packages('GGally')
library(GGally)
names(mtcars)
View(mtcars)
plot(mtcars$mpg,
mtcars$hp,
pch = mtcars$am,
xlab = "horsepower",
cex = 1.2,
ylab = "mpg",
main = "mpg vs hp using transmission")
legend("topright", c("automatic", "manual"), pch = c(0,1))
names(mpg)
qplot(x = wt
y = mpg
data = mtcars
size = cyl,
main = "MPG vs Weight using cylinder")
View(mpg)
View(data)
data("midwest")
plot(midwest$state,
midwest$percprof,
pch = 17, col = 2, cex = 1.2,
xlab = "states",
ylab = "Professional Education"
)
qplot(x = state,
y = percprof,
data = midwest,
main = "State Vs PercProf")
View(midwest)
ggplot(midwest, aes(state, percprof)) + geom_histogram(binwidth = 2)
ggplot(midwest, aes(x = state, y = percprof)) + geom_histogram(binwidth = 2)
ggplot(midwest, aes(x = state, y = percprof)) + geom_line() + geom_point()
ggplot(midwest, aes(x = state, y = percprof)) + geom_boxplot()
ggplot(midwest, aes(x = state, y = percprof)) + geom_bar(stat = "identity")
names(mpg)
qplot(x = wt
y = mpg
data = mtcars
size = cyl,
main = "MPG vs Weight using cylinder")
qplot(x = wt,
y = mpg,
data = mtcars,
size = cyl,
main = "MPG vs Weight using cylinder")
data("midwest")
qplot(x = state,
y = percprof,
data = midwest,
size = county,
main = "State Vs PercProf")
qplot(x = state,
y = percprof,
data = midwest,
main = "State Vs PercProf")
ggplot(midwest, aes(x = state, y = percprof)) + geom_boxplot()
ggplot(midwest, aes(y = percprof, x = state)) + geom_violin(scale = "area")
View(midwest)
qplot(x = state,
y = perchsd,
data = midwest,
main = "Percentage with HS Diploma VS. State")
ggplot(midwest, aes(x = state, y = perchsd)) + geom_violin(scale = "area")
plot(mtcars$mpg,
mtcars$hp,
pch = mtcars$am,
xlab = "horsepower",
cex = 1.2,
ylab = "mpg",
main = "mpg vs hp using transmission")
legend("topright", c("automatic", "manual"), pch = c(0,1))
plot(faithful$eruptions, xlab = "sample number", ylab = "eruption times(min)", main = "Old Faithful Erution Times")
S = sort.int(mpg$cty, index.return = T)
plot(S$x, type = "l", lty = 2, xlab = "sample number (sorted by city mpg)", ylab = "mpg")
lines(mpg$hwy[S$ix], lty = 1)
legend("topleft", c("highway mpg", "city mpg"), lty = c(1,2))
plot(midwest$state,
midwest$perchsd,
pch = 17,
col = 2,
cex = 1.2,
xlab = "States",
ylab = "Percentage with HS Diploma")
ggplot(midwest, aes(x = state, y = perchsd)) + geom_violin(scale = "area")
ggplot(midwest, aes(x = state, y = perchsd)) + geom_boxplot()
ggplot(midwest, aes(y = percprof, x = state)) + geom_violin(scale = "area")
qplot(x = state,
y = county,
data = midwest,
size = percprof,
main = "State Vs PercProf")
qplot(x = state,
y = percprof,
data = midwest,
size = county,
main = "State Vs PercProf")
plot(midwest$state,
midwest$percprof,
pch = 17, col = 2, cex = 1.2,
xlab = "states",
ylab = "Professional Education"
)
qplot(x = state,
y = percprof,
data = midwest,
size = county,
main = "State Vs PercProf")
qplot(x = state,
y = county,
data = midwest,
size = percprof,
main = "State Vs PercProf")
ggplot(midwest, aes(x = state, y = perchsd)) + geom_boxplot()
x = 1:10
print(x^2)
plot(x, x^2, 'o')
load('movies_merged')
cat("Dataset has", dim(movies_merged)[1], "rows and", dim(movies_merged)[2], "columns", end="\n", file="")
df = movies_merged
cat("Column names:", end="\n", file="")
colnames(df)
library(ggplot2)
library(GGally)
# TODO: Remove all rows from df that do not correspond to movies
df2 <- df[df$Type == "movie",]
dim(df2)
View(df2)
x = 1:10
print(x^2)
plot(x, x^2, 'o')
load('movies_merged')
cat("Dataset has", dim(movies_merged)[1], "rows and", dim(movies_merged)[2], "columns", end="\n", file="")
df = movies_merged
test = movies_merged
cat("Column names:", end="\n", file="")
colnames(df)
install.packages("NLP",dependencies = TRUE)
install.packages('reshape2')
install.packages("tm")
install.packages("ggplot2")
install.packages("GGally")
install.packages("tidyr")
install.packages("SnowballC")
install.packages("lubridate")
library(ggplot2)
library(GGally)
library(tidyr)
library(NLP)
library(tm)
library(plyr)
library(reshape2)
library(SnowballC)
library(lubridate)
library(stringr)
# TODO: Remove all rows from df that do not correspond to movies
df2 <- df[df$Type == "movie",]
dim(df2)
# TODO: Replace df$Runtime with a numeric column containing the runtime in minutes
#NoNarun_time <- df2$Runtime
#NoNarun_time[is.character(NoNarun_time) & NoNarun_time == "N/A"] <- "0 min"
raw_run_time <- df2$Runtime
h_run_time <- as.numeric(gsub(".*?(\\d+) [Hh]r?.*", "\\1", raw_run_time))
h_run_time[is.na(h_run_time)] <- 0
m_run_time <- as.numeric(gsub(".*?(\\d+) [Mm]in?.*", "\\1", raw_run_time))
m_run_time[is.na(m_run_time)] <- 0
run_time <- (h_run_time * 60) + m_run_time
df2$Runtime <- run_time
typeof(df2$Runtime)
# TODO: Investigate the distribution of Runtime values and how it varies by Year and Budget
summary(df2$Year)
summary(df2$Budget)
summary(df2$Runtime)
df2$Period = cut(x = df2$Year, breaks = c(1880, seq(1890,2020, by=10)))
ggplot(df2, aes(x = Period, y = Runtime)) + geom_point() + geom_line() +#geom_bar(stat = "identity") +
theme(axis.text.x = element_text(angle = 90)) + ggtitle("Runtime VS Year") +
xlab("Years divided into decades") + ylab("Runtime in Min")
df2$Div_runtime = cut(x = df2$Runtime, breaks = c(0, seq(25,875, by=25)))
ggplot(df2, aes(x = Div_runtime, y = Budget)) + geom_point() + geom_line() +
theme(axis.text.x = element_text(angle = 90)) + ggtitle("Runtime VS Budget") +xlab("Runtime in Min") + ylab("Budget in Dollars($)")
# TODO: Replace Genre with a collection of binary columns
summary(df2$Genre)
View(df2)
genre_dictionary <- unique(unlist(strsplit(df2$Genre, ", ")))
genre = data.frame(matrix(nrow = nrow(df2), ncol = length(genre_dictionary)))
colnames(genre) = genre_dictionary
genre[] = 0
for (x in genre_dictionary)
{
genre[grep(x, df2[, "Genre"]), x] = 1
#here we compare each and every genre value to the original dataset and the dictionary,
#searching for x in df2 dataframe$genre, will put 1 if it encounters any of the genres in genre data frame or will put a zero.
#total number of genres is 29, so there will be 29 extra rows.
}
new_genre = cbind(df2, genre)
#final step is to attach the set of binary columns to the original dataframe
# TODO: Select movies from top 10 most common genres and plot their relative proportions
metrics = colSums(genre)
sorted = sort(metrics, decreasing = TRUE)
#relative proportions = total count / number of rows
#taking top 10 genres
rel_prop = (sorted[1:10]) / nrow(df2)
#rel_prop <- data.frame(rel_prop)
pie(rel_prop)
# TODO: Plot Runtime distribution for top 10 most common genres
for (y in names(sorted[1:10]))
{
assign(y, new_genre[new_genre[, y]==1,])
}
#assinging a dataframe consisting of each specific genre to each drama for easier plotting
for (y in names(sorted[1:10]))
{
plot(get(y)[!is.na(get(y)$Runtime), "Runtime"], main = paste("Plot: ", y, " And Runtime"))
}
# TODO: Remove rows with Year/Date/Released mismatch
time_df <- data.frame(new_genre$Title, new_genre$Year, new_genre$Released, new_genre$Date, new_genre$Gross)
df3 <- new_genre
df3$Released = as.Date(df3$Released, "%Y-%m-%d")
df3$Year_of_Release = as.numeric(format(df3$Released, "%Y"))
bad_data <- df3[(df3$Year == df3$Year_of_Release) | ((df3$Year + 1) == df3$Year_of_Release),]
before = length(df3$Gross[!is.na(df3$Gross)])
after = length(bad_data$Gross[!is.na(bad_data$Gross)])
percentage = ((before - after)/after) * 100
# TODO: Investigate if Gross Revenue is related to Budget, Runtime or Genre
gross_revenue = subset(new_genre, !is.na(new_genre$Gross))
gross_revenue <- gross_revenue[gross_revenue$Gross != 0, ]
summary(new_genre$Runtime)
small_runtime = subset(gross_revenue, gross_revenue$Runtime < 69) #1st quartile value
long_runtime = subset(gross_revenue, gross_revenue$Runtime > 100) #3rd quartile value
ggplot(gross_revenue, aes(x = log10(Budget), y = log10(Gross))) + geom_point() + geom_line() + ggtitle("Budget vs Gross Revenue")
ggplot(small_runtime, aes(Runtime, Gross)) + geom_point() + geom_line() + ggtitle("Shorter Runtime vs Gross Revenue")
ggplot(long_runtime, aes(Runtime, Gross)) + geom_point() + geom_line() + ggtitle("Longer Runtime vs Gross Revenue")
# TODO: Investigate if Gross Revenue is related to Release Month
release_month <- month(as.POSIXct(bad_data$Released, format = "%y-%m-%d"))
bad_data$release_month <- month.abb[release_month]
ggplot(bad_data, aes(bad_data$release_month, bad_data$Gross)) +
geom_bar(stat = "identity") + xlab("Released Month") + ylab("Gross Revenue") +
ggtitle("Gross Revenue vs Release Month")
# TODO: Convert Awards to 2 numeric columns: wins and nominations
for (a in c(1:nrow(new_genre)))
{
aw1 = 0
aw2 = 0
if(grepl("Won", new_genre[a, "Awards"])) {
aw1=as.numeric(str_extract(str_extract(new_genre[a,"Awards"], "Won ([\\d]+)"), "[[:digit:]]+"))
aw1=aw1+as.numeric(str_extract(str_extract(new_genre[a,"Awards"], "([\\d]+) win"), "[[:digit:]]+"))
aw2=aw2+as.numeric(str_extract(str_extract(new_genre[a,"Awards"], "([\\d]+) nomination"), "[[:digit:]]+"))
}
else if(grepl("Nominated",new_genre[a, "Awards"])){
aw2=as.numeric(str_extract(str_extract(new_genre[a,"Awards"], "Nominated for ([\\d]+)"), "[[:digit:]]+"))
aw1=aw1+as.numeric(str_extract(str_extract(new_genre[a,"Awards"], "([\\d]+) win"), "[[:digit:]]+"))
aw2=aw2+as.numeric(str_extract(str_extract(new_genre[a,"Awards"], "([\\d]+) nomination"), "[[:digit:]]+"))
}
else{
aw1=aw1+as.numeric(str_extract(str_extract(new_genre[a,"Awards"], "([\\d]+) win"), "[[:digit:]]+"))
aw2=aw2+as.numeric(str_extract(str_extract(new_genre[a,"Awards"], "([\\d]+) nomination"), "[[:digit:]]+"))
}
new_genre[a,"wins"]=aw1
new_genre[a, "nominations"]=aw2
if(is.na(new_genre[a,"wins"])){new_genre[a,"wins"]=0}
if(is.na(new_genre[a,"nominations"])){new_genre[a,"nominations"]=0}
}
# TODO: Plot Gross revenue against wins and nominations
ggplot(new_genre, aes(x = wins, y = Gross)) + geom_point() + geom_line() + ggtitle("Gross Revenue vs Number of Wins") + xlab("Number of Wins") + ylab("Gross Revenue")
ggplot(new_genre, aes(x = nominations, y = Gross)) + geom_point() + geom_line() + ggtitle("Gross Revenue vs Number of Nomintations") + xlab("Number of Nominations") + ylab("Gross Revenue")
# TODO: Illustrate how ratings from IMDb and Rotten Tomatoes are related
ggplot(new_genre, aes(x = imdbRating, y = tomatoMeter)) + geom_quantile()
ggpairs(new_genre[,c("imdbRating", "imdbVotes", "tomatoMeter", "tomatoRating", "tomatoUserRating", "tomatoFresh")])
# TODO: Show how ratings and awards are related
new_genre$AwardCount <- new_genre$wins + new_genre$nominations
ggplot(new_genre, aes(x = imdbRating, y = AwardCount)) + geom_point() + geom_line() + ggtitle("IMDB Ratings vs Number of Awards(wins and nominations)")
ggplot(new_genre, aes(x = imdbVotes, y = AwardCount)) + geom_point() + geom_line() + ggtitle("IMDB Votes vs Number of Awards(wins and nominations)")
ggplot(new_genre, aes(x = tomatoMeter, y = AwardCount)) + geom_point() + geom_line() + ggtitle("Rotten Tomato's Meter vs Number of Awards(wins and nominations)")
ggplot(new_genre, aes(x = tomatoUserRating, y = AwardCount)) + geom_point() + geom_line() + ggtitle("Rotten Tomato's User's Ratings vs Number of Awards(wins and nominations)")
# TODO: Find and illustrate two expected insights
#new_genre$Metascore[is.na(new_genre$Metascore)]
#INSIGHT1
#RELATIONSHIP BETWEEN METASCORE AND AWARD COUNT
ggplot(new_genre, aes(x = Metascore, y = AwardCount)) + geom_boxplot() +
theme(axis.text.x = element_text(angle = 90)) + ggtitle("Metascore vs Awards Won/Nominated For")
#INSIGHT2
#RELATIONSHIP BETWEEN DOMESTIC GROSS AND  GROSS REVENUE
ggplot(new_genre, aes(x = Domestic_Gross, y = Gross)) + geom_point() + geom_line() + ggtitle("Domestic Gross vs Gross Revenue")
# TODO: Find and illustrate one unexpected insight
ggplot(new_genre, aes(x = Budget, y = Gross)) + geom_point() + geom_line() + ggtitle("Relationship with Budget and Gross Revenue")
ggplot(new_genre, aes(x = Budget, y = tomatoRating)) + geom_point() + geom_line() + ggtitle("Relationship between Critic Rating and Budget")
x = matrix(c(1:20), nrow = 5, ncol = 4)
x
y <- x[1,] %*% t(x[3,])
y
load('movies_merged')
cat("Dataset has", dim(movies_merged)[1], "rows and", dim(movies_merged)[2], "columns", end="\n", file="")
test <- is.na(movies_merged)
View(test)
getwd()
setwd("F:/GA-Tech/Summer 2018/CSE6242/Homework3/mnist")
getwd()
getwd()
setwd("F:/GA-Tech/Summer 2018/CSE6242/Homework3/mnist")
#Reading csv files separately
if((file.exists("mnist_test.csv")) && (file.exists("mnist_train.csv"))) {
tr_set <- read.csv(file = "mnist_train.csv", header = FALSE)
te_set <- read.csv(file = "mnist_test.csv", header = FALSE)
}
mtcars
t(mtcars)
def <- mtcars
View(def)
def2 <- t(mtcars)
def2
is.data.frame(tr_set)
tr_set <- as.data.frame(t(tr_set))
te_set <- as.data.frame(t(te_set))
#partitioning training set
names(tr_set)
tr_set[785]
tr_set(785)
names(def)
def[12]
def[11]
View(def)
#partitioning training set
names(tr_set)[785] <- "Label"
names(te_set)[785] <- "Label"
train_0_1 <- tr_set[(tr_set$Label == 0) | (tr_set$Label == 1),]
train_3_5 <- tr_set[(tr_set$Label == 3) | (tr_set$Label == 5),]
#partitioning testing set based on given classification
test_0_1 <- te_set[(te_set$Label == 0) | (te_set$Label == 1),]
test_3_5 <- te_set[(te_set$Label == 3) | (te_set$Label == 5),]
dim(train_0_1)
names(def)
names(train_0_1)
names(tr_set)
names(train_0_1)
head(train_0_1)
blah < - head(train_0_1)
blah < - as.data.frame(head(train_0_1))
train_0_1(1:10,train_0_1$Label)
train_0_1(1:10,"Label")
train_0_1(1:10,)
train_0_1[1:10,train_0_1$Label]
test <- train_0_1[1:10,train_0_1$Label]
View(test)
test <- train_0_1[1:10,]
test <- train_0_1[1:3,]
View(test)
test$Label <- NULL
View(test)
train_0_1$Label <- NULL
true_train35 <- train_3_5$Label
train_3_5$Label <- NULL
true_test01 <- test_0_1$Label
test_0_1$Label <- NULL
true_test35 <- test_3_5$Label
train_0_1 <- tr_set[(tr_set$Label == 0) | (tr_set$Label == 1),]
true_train01 <- train_0_1$Label
train_0_1$Label <- NULL
test_3_5$Label <- NULL
tmp <- tr_set[tr_set$Label == 0,]
tr0 <- tr_set[tr_set$Label == 0,]
tr1 <- tr_set[tr_set$Label == 1,]
tr3 <- tr_set[tr_set$Label == 3,]
tr5 <- tr_set[tr_set$Label == 5,]
tr0_mat <- matrix(unlist(tr0[1,1:784]), ncol = 28, byrow = TRUE)
tr1_mat <- matrix(unlist(tr1[1,1:784]), ncol = 28, byrow = TRUE)
tr3_mat <- matrix(unlist(tr3[1,1:784]), ncol = 28, byrow = TRUE)
tr5_mat <- matrix(unlist(tr5[1,1:784]), ncol = 28, byrow = TRUE)
image(tr0_mat, col = gray(0:255))
image(tr0_mat, col = gray(255))
image(tr0_mat, col = gray(1))
image(tr0_mat, col = gray.colors(256))
image(tr1_mat, col = gray.colors(256))
image(tr3_mat, col = gray.colors(256))
image(tr5_mat, col = gray.colors(256))
te0 <- te_set[te_set$Label == 0,]
te1 <- te_set[te_set$Label == 1,]
te3 <- te_set[te_set$Label == 3,]
te5 <- te_set[te_set$Label == 5,]
te0_mat <- matrix(unlist(te0[1,1:784]), ncol = 28, byrow = TRUE)
te1_mat <- matrix(unlist(te1[1,1:784]), ncol = 28, byrow = TRUE)
te3_mat <- matrix(unlist(te3[1,1:784]), ncol = 28, byrow = TRUE)
te5_mat <- matrix(unlist(te5[1,1:784]), ncol = 28, byrow = TRUE)
image(te0_mat, col = gray.colors(256))
image(te1_mat, col = gray.colors(256))
image(tr1_mat, col = gray.colors(256))
image(te1_mat, col = gray.colors(256))
image(tr0_mat, col = gray.colors(256))
image(te0_mat, col = gray.colors(256))
image(te1_mat, col = gray.colors(256))
image(te3_mat, col = gray.colors(256))
image(te5_mat, col = gray.colors(256))
