load('movies_merged')
df = movies_merged
cat("Dataset has", dim(df)[1], "rows and", dim(df)[2], "columns", end="\n", file="")
colnames(df)
install.packages("NLP",dependencies = TRUE)
install.packages('reshape2')
install.packages("tm")
install.packages("ggplot2")
install.packages("GGally")
install.packages("tidyr")
install.packages("SnowballC")
install.packages("lubridate")
library(ggplot2)
library(GGally)
library(tidyr)
library(NLP)
library(tm)
library(plyr)
library(reshape2)
library(SnowballC)
library(lubridate)
library(stringr)
# TODO: Remove all rows from df that do not correspond to movies
df <- df[df$Type == "movie", ]
dim(df)
# TODO: Remove rows with missing Gross value
df <- df[!is.na(df$Gross),]
df <- df[!(df$Gross == 0),]
# TODO: Exclude movies released prior to 2000
df <- df[!(df$Year < 2000),]
# TODO: Remove mismatched rows
rows <- df
rows$Released <- as.Date(rows$Released, "%Y-%m-%d")
rows$RelYear <- as.numeric(format(rows$Released, "%Y"))
mismatchedrows <- rows[(rows$Year == rows$RelYear),]
df <- subset(mismatchedrows, select = -RelYear)
dim(rows)[1]
removed_perc <- (((dim(rows)[1]) - dim(df)[1])/(dim(df)[1])) * 100)
removed_perc <- ((dim(rows)[1] - dim(df)[1])/(dim(df)[1])) * 100
removed_perc <- ((dim(rows)[1] - dim(df)[1])/(dim(rows)[1])) * 100
cat("Removed ",removed_perc, "% of rows")
load('movies_merged')
df = movies_merged
cat("Dataset has", dim(df)[1], "rows and", dim(df)[2], "columns", end="\n", file="")
colnames(df)
#install.packages("NLP",dependencies = TRUE)
#install.packages('reshape2')
#install.packages("tm")
#install.packages("ggplot2")
#install.packages("GGally")
#install.packages("tidyr")
#install.packages("SnowballC")
#install.packages("lubridate")
library(ggplot2)
library(GGally)
library(tidyr)
library(NLP)
library(tm)
library(plyr)
library(reshape2)
library(SnowballC)
library(lubridate)
library(stringr)
# TODO: Remove all rows from df that do not correspond to movies
df <- df[df$Type == "movie", ]
dim(df)
# TODO: Remove rows with missing Gross value
df <- df[!is.na(df$Gross),]
df <- df[!(df$Gross == 0),]
# TODO: Exclude movies released prior to 2000
df <- df[!(df$Year < 2000),]
# TODO: Remove mismatched rows
rows <- df
rows$Released <- as.Date(rows$Released, "%Y-%m-%d")
rows$RelYear <- as.numeric(format(rows$Released, "%Y"))
mismatchedrows <- rows[(rows$Year == rows$RelYear),]
df <- subset(mismatchedrows, select = -RelYear)
removed_perc <- ((dim(rows)[1] - dim(df)[1])/(dim(rows)[1])) * 100
cat("Removed ",removed_perc, "% of rows")
# TODO: Exclude the `Domestic_Gross` column
df$Domestic_Gross <- NULL
# TODO: Replace df$Runtime with a numeric column containing the runtime in minutes
#below code for this step taken from my own submission for project 1
raw_run_time <- df$Runtime
h_run_time <- as.numeric(gsub(".*?(\\d+) [Hh]r?.*", "\\1", raw_run_time))
h_run_time[is.na(h_run_time)] <- 0
m_run_time <- as.numeric(gsub(".*?(\\d+) [Mm]in?.*", "\\1", raw_run_time))
m_run_time[is.na(m_run_time)] <- 0
run_time <- (h_run_time * 60) + m_run_time
df$Runtime <- run_time
# TODO(optional): Additional preprocessing
# TODO: Print the dimensions of the final preprocessed dataset and column names
cat("Dataset has", dim(df)[1], "rows and", dim(df)[2], "columns", end="\n", file="")
colnames(df)
# TODO: Build & evaluate model 1 (numeric variables only)
test <- df
test$Metascore<-as.numeric(as.character(test$Metascore))
test_na<-na.omit(test)
numset_test<-sapply(test_na,is.numeric)
which_numset_test<-which(numset_test)
numset_test_vals<-test_na[,which_numset_test]
numset_test_vals<-subset(numset_test_vals,select=-tomatoRotten)
set.seed(101)
tmp_train_vals<-sample(1:nrow(numset_test_vals),size=floor(0.8*nrow(numset_test_vals)))
tmp_test_vals <- sample(1:nrow(numset_test_vals),size=floor(0.2*nrow(numset_test_vals)))
rmse_func <-function(trainingset,testingset,ratio){
tr_rmse=c()
te_rmse=c()
for(i in 1:10){
set.seed(120)
tmp_train_vals_r<-sample(1:nrow(trainingset),size=floor(ratio*nrow(trainingset)))
tmp_test_df<-trainingset[tmp_train_vals_r,]
theta=lm(Gross~.,tmp_test_df)
pdct_for_te_set = predict(theta,testingset)
pdct_for_te_set<-as.data.frame(pdct_for_te_set)
val_for_test=sqrt(mean((testingset$Gross - pdct_for_te_set)^2))
tr_rmse=c(tr_rmse,sqrt(residuals(theta)^2))
te_rmse=c(te_rmse,val_for_test)
}
final=c()
final = c(final,mean(tr_rmse))
final =c(final,mean(te_rmse))
return (final)
}
trainer<-function(data,var_data){
sizes = c(0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.45,0.5,0.55,0.6,0.65,0.7,0.75,0.8,0.85,0.9,0.95,1)
model_tr_rms = c()
model_te_rms=c()
tr_data_s<-data[var_data,]
te_data_s<-data[-var_data,]
for (val in sizes)
{
rms_result=rmse_func(tr_data_s,te_data_s,val)
print (rms_result)
model_tr_rms = c(model_tr_rms,rms_result[1])
model_te_rms=c(model_te_rms,rms_result[2])
}
rmse_model1<-data.frame(sizes,model_tr_rms,model_te_rms)
return( rmse_model1)
}
model1=trainer(numset_test_vals,tmp_train_vals)
ggplot(model1,aes(sizes))+geom_line(aes(y=model_tr_rms))
#model1=trainer(numset_test_vals, tmp_test_vals)
#ggplot(model1,aes(sizes))+geom_line(aes(y=model_te_rms))
# TODO: Build & evaluate model 2 (transformed numeric variables only)
numset_test_vals$t_rat_pr2<-numset_test_vals$tomatoRating^2
numset_test_vals$t_rat_pr3<-numset_test_vals$tomatoRating^3
numset_test_vals$t_fresh_pr2<-numset_test_vals$tomatoFresh^2
numset_test_vals$t_fresh_pr3<-numset_test_vals$tomatoFresh^3
numset_test_vals$t_usrev_pr2<-numset_test_vals$tomatoUserReviews^2
numset_test_vals$t_usrev_pr3<-numset_test_vals$tomatoUserReviews^3
numset_test_vals$t_usmet_pr2<-numset_test_vals$tomatoUserMeter^2
numset_test_vals$t_usmet_pr3<-numset_test_vals$tomatoUserMeter^3
numset_test_vals$t_usrat_pr2<-numset_test_vals$tomatoUserRating^2
numset_test_vals$t_usrat_pr3<-numset_test_vals$tomatoUserRating^3
numset_test_vals$t_rev_pr2<-numset_test_vals$tomatoReviews^2
numset_test_vals$t_rev_pr3<-numset_test_vals$tomatoReviews^3
numset_test_vals$t_met_pr2<-numset_test_vals$tomatoMeter^2
numset_test_vals$t_met_pr3<-numset_test_vals$tomatoMeter^3
numset_test_vals$rt_pr2<-numset_test_vals$Runtime^2
numset_test_vals$rt_pr3<-numset_test_vals$Runtime^3
numset_test_vals$ms_pr2<-numset_test_vals$Metascore^2
numset_test_vals$ms_pr3<-numset_test_vals$Metascore^3
numset_test_vals$imdb_votes_pr2<-numset_test_vals$imdbVotes^2
numset_test_vals$imdb_votes_pr3<-numset_test_vals$imdbVotes^3
transformed_runtime<-test_na$Runtime
numset_test_vals$rt_Bin<-cut(transformed_runtime,seq(min(transformed_runtime)-1,max(transformed_runtime)+1,(max(transformed_runtime) - min(transformed_runtime)+2)/6),right=FALSE,labels=c(1:6))
numset_test_vals$rt_Bin<-as.numeric(numset_test_vals$rt_Bin)
binned_imdb_rat<-numset_test_vals$imdbRating
numset_test_vals$binned_imdb_rating_val<-cut(binned_imdb_rat,seq(min(binned_imdb_rat)-1,max(binned_imdb_rat)+1,(max(binned_imdb_rat) - min(binned_imdb_rat)+2)/4),right=FALSE,labels=c(1:4))
numset_test_vals$binned_imdb_rating_val<-as.numeric(numset_test_vals$binned_imdb_rating_val)
fitted_model1 <- lm(Gross~., data = numset_test_vals)
summary(fitted_model1)
numset_test_vals<-subset(numset_test_vals,select=-c(t_rat_pr2,t_rat_pr3,t_fresh_pr2,t_fresh_pr3,t_usmet_pr2,t_usmet_pr3,t_usrat_pr2,t_usrat_pr3,t_met_pr2,t_met_pr3,rt_pr2,rt_pr3,ms_pr2,ms_pr3,imdb_votes_pr2,rt_Bin))
model2=trainer(numset_test_vals,tmp_train_vals)
ggplot(model1,aes(sizes))+geom_line(aes(y=model_tr_rms))
# TODO: Build & evaluate model 3 (converted non-numeric variables only)
#df_nagenre<-test_na
#nagenre<-df_nagenre$Genre
#applying text mining transformations to the genre column to encode it
tm_file = Corpus(VectorSource(test_na$Genre))
#removing all whitespaces from the column from each row
tm_file <- tm_map(tm_file, stripWhitespace)
#converting all values into lower case characters
tm_file <- tm_map(tm_file, tolower)
#removing any punctuation marks such as , or . etc.
tm_file <- tm_map(tm_file, removePunctuation)
#using the tm_map function to the created corpus vector
tm_map(tm_file, stemDocument, language="english")
collection <- DocumentTermMatrix(tm_file)
tmp_genre_converted <- data.frame(as.matrix(collection))
sort(colSums(tmp_genre_converted),decreasing = T)[1:10]
top10_genre_list <- sort(colSums(tmp_genre_converted), decreasing = TRUE)
#name_list <- names(top10_genre_list)
converted_genre_vector <- tmp_genre_converted[,names(top10_genre_list)]
#to sum up the steps that i used for encoding this genre feature, I listed out the
#top 10 genres of all the movies and created a collection out of them.
#then i assigned binary values to a genre vector which had the genres listed out in order
#and had a 1 for a genre listed and matching that in the collection and vice versa
#converting the Production dataset column into an encoded feature
length(sort(table(test_na$Production), decreasing = T))
# observing only the top 15 productions
sort(table(test_na$Production), decreasing = T)[1:15]
#Chose the top 5 variables within that dataset column
movie_prod <- data.frame(matrix(0, nrow = nrow(test_na), ncol = 5))
colnames(movie_prod) <- c("war_prod", "uni_prod", "twenty_prod", "para_prod", "sony_prod")
for(i in seq_along(test_na$Production)){
if ( test_na$Production[i] == "Warner Bros. Pictures" ){
movie_prod$war_prod[i] <-  1
}else if(test_na$Production[i] == "Universal Pictures"){
movie_prod$uni_prod[i] <- 1
}else if(test_na$Production[i] == "20th Century Fox"){
movie_prod$twenty_prod[i] <- 1
}else if(test_na$Production[i] == "Paramount Pictures"){
movie_prod$para_prod[i] <- 1
}else if(test_na$Production[i] == "Sony Pictures"){
movie_prod$sony_prod[i] <- 1
}
}
#Transforming awards into an encoded feature
test_na$Award_Winnings = 0
test_na$Awards_Nominations = 0
Not_Award=0
for(i in 1:nrow(test_na)){
val = as.numeric( unlist(
regmatches(test_na[i,'Awards'], gregexpr("+[0-9]+", test_na[i,'Awards']))))
if(length(val)[1] == 1)
{
if((length(grep("win",test_na[i,]$Awards))>0) || (length(grep("won",test_na[i,]$Awards))>0)|| (length(grep("Win",test_na[i,]$Awards))>0)|| (length(grep("Won",test_na[i,]$Awards))>0)){
test_na[i,]$Award_Winnings = as.numeric(val[1])
}
if(length(grep("nomination",test_na[i,]$Awards))>0){
test_na[i,]$Awards_Nominations = as.numeric(val[1])
}
}
if(length(val)[1] == 2)
{
if((length(grep("win",test_na[i,]$Awards))>0) || (length(grep("won",test_na[i,]$Awards))>0)|| (length(grep("Win",test_na[i,]$Awards))>0)|| (length(grep("Won",test_na[i,]$Awards))>0)){
test_na[i,]$Award_Winnings = as.numeric(val[1])
}
if(length(grep("nomination",test_na[i,]$Awards))>0){
test_na[i,]$Awards_Nominations = as.numeric(val[2])
}
}
if(length(val)[1] == 3)
{
if((length(grep("win",test_na[i,]$Awards))>0) || (length(grep("won",test_na[i,]$Awards))>0)|| (length(grep("Win",test_na[i,]$Awards))>0)|| (length(grep("Won",test_na[i,]$Awards))>0)){
test_na[i,]$Award_Winnings = as.numeric(val[2])
}
if(length(grep("nomination",test_na[i,]$Awards))>0){
test_na[i,]$Awards_Nominations = as.numeric(val[3])
}
}
if(length(val)[1] == 0){
test_na[i,]$Award_Winnings = 0
test_na[i,]$Awards_Nominations = 0
Not_Award = Not_Award + 1
}
}
base_model2 <- cbind( converted_genre_vector,movie_prod,no_of_wins=test_na$Award_Winnings,no_of_noms=test_na$Awards_Nominations,Gross=test_na$Gross)
row.names(base_model2)<-row.names(numset_test)
base_model2<-subset(base_model2,select=-c(comedy,romance,thriller,crime,mystery,family,biography,music,sport,history,documentary,war,musical,western,news,no_of_wins,para_prod))
fitted_model_1 <- lm(Gross~., data = base_model2)
summary(fitted_model_1)
model3=trainer(base_model2,tmp_train_vals)
ggplot(model3,aes(sizes))+geom_line(aes(y=model_tr_rms))
# TODO: Build & evaluate model 4 (numeric & converted non-numeric variables)
base_model2<-subset(base_model2,select=-Gross)
base_model4 <- cbind(base_model2,numset_test_vals)
fitted_model1 <- lm(Gross~., data = base_model4)
summary(fitted_model1)
base_model4<-subset(base_model4,select=-c(tomatoFresh,sony_prod,uni_prod,twenty_prod,horror,fantasy,adventure,drama))
model4 = trainer(base_model4,tmp_train_vals)
ggplot(model4,aes(sizes))+geom_line(aes(y=model_tr_rms))
# TODO: Build & evaluate model 5 (numeric, non-numeric and additional features)
cat = 1:5
num = 6:24
new_feat <- data.frame(matrix(0, nrow = dim(base_model4)[1], ncol= 0))
new_feat_colnames<-c()
for (i in num){
for (j in cat){
tmp <- paste("relate", colnames(base_model4)[i], colnames(base_model4)[j], sep = "_")
new_feat_colnames <- c(new_feat_colnames, tmp)
cols = base_model4[i] * base_model4[j]
new_feat <- cbind(new_feat, cols)
}
}
colnames(new_feat) <- new_feat_colnames
new_df <- cbind(base_model4, new_feat)
fitted_model5 <- lm(Gross~., data = new_df)
base_model5 <- new_df[, (summary(fitted_model5)$coefficients[, 4] < 0.05)]
model5 = trainer(base_model5,tmp_train_vals)
ggplot(model5,aes(sizes))+geom_line(aes(y=model_tr_rms))
View(model5)
allModels<-merge(model1,model2,by="sampling_list")
allModels<-merge(model1,model2,by="sizes")
allModels<-merge(allModels,model3,by="sizes")
allModels<-merge(allModels,model4,by="sizes")
allModels<-merge(allModels,model5,by="sizes")
View(allModels)
colnames(allModels)<-c("sizes","model1","model1_test","model2","model2_test","model3","model3_test","model4","model4_test","model5","model5_test")
allModels$model1_test <- NULL
allModels$model2_test <- NULL
allModels$model3_test <- NULL
allModels$model4_test <- NULL
allModels$model5_test <- NULL
ggplot(allModels, aes(sizes)) + geom_line(aes(y = model1, color = "model1"))+
geom_line(aes(y = model2, color = "model2")) +
geom_line(aes(y = model3, color = "model3")) +
geom_line(aes(y = model4, color = "model4")) +
geom_line(aes(y = model5, color = "model5"))
